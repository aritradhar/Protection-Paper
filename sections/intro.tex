\section{Introduction}
\label{sec:intro}

Web-based interfaces are very prevalent to remotely configure safety-critical systems such as remote PLCs~\cite{controlbyweb} or medical devices~\cite{medicalDevice}, and other security-sensitive applications such as online payments, e-voting, etc. The high complexity of modern operating systems, software, and hardware components has shown that computer systems largely remain vulnerable to attacks. A compromised computer threatens the integrity and the confidentiality of any interaction between the user and a remote server. It can easily observe and/or manipulate the sensitive IO data exchanged between the user and the remote server, or even trick the user to perform unintended actions. 

The recent introduction of trusted computing architectures like Intel's SGX has enabled secure computations and secure data storage on otherwise untrusted computing platforms. However, such architectures do not directly enable secure user interaction because IO operations are handled by the operating system. Additionally, the recent microarchitectural attacks have shown that execution environments inside enclaves, like the one provided by SGX, can be compromised as well.


\emph{Trusted path} provides a secure channel between the user (specifically human interface device - HID) and the end-point, which is typically a trustworthy application running on the host. Trusted path ensures that user inputs reach the intended application unmodified, and all the outputs presented to the user are generated by the legitimate application. Trusted path to the local host is a well-researched area where many solutions focus on using trusted software components such as a trusted hypervisor. Zhou et al.~\cite{zhou2012building} proposed a generic trusted path on $x86$ systems with a pure hypervisor-based design. SGXIO~\cite{weiser2017sgxio} employs both a hypervisor and Intel SGX. However, hypervisors are hard to deploy, have a large TCB, and are impractical in real-world scenarios as most of the existing verified hypervisors offer a minimal set of features. 


Trusted external devices are another way to realize secure IO between a user and a remote server. Transaction confirmation devices~\cite{filyanov2011uni,weigold2011secure} allow the user to review her input data on a trusted device that is physically separated from the untrusted host. These approaches suffer from poor usability, security issues due to user habituation and are only limited to simple inputs. In Section~\ref{sec:problemStatement:existingSolution}, we provide a more detailed discussion on the security and the usability of transaction confirmation devices. Bump in the Ether~\cite{McCPerRei2006} and IntegriKey~\cite{IntegriKey} use external embedded devices to sign input parameters. However, such solutions do not support output integrity; hence, the attacker can execute UI manipulation attacks to trick the user into providing incorrect inputs. %Trusted overlay-based approach~\cite{brandon2017trusted} uses a trusted FPGA to overlay UI elements such as a PIN entry screen on the LCD where the user can safely enter passwords. \red{The approach has several drawbacks - i) lack of support for UI elements apart from text field, ii) there is no way for the user to distinguish attacker-rendered UI from the trusted overlaid UI, iii) lack of mouse support, and iv) lack of integration with applications such as browsers.}


Fidelius~\cite{Fidelius} combines the previous ideas of Bump in the Ether and trusted overlay to protect keyboard inputs from a compromised browser using external devices and a \js interpreter that runs inside an SGX enclave. Fidelius maintains overlays on display, specifically on the input text boxes to hide sensitive user inputs from the browser. We investigate the security of Fidelius and discover several issues. Fidelius imposes a high cognitive load to the users as they need to monitor continuously different security indicators (two LED lights and the status bar on the screen) to guarantee the integrity and confidentiality of the input. Furthermore, the attacker can manipulate labels of the UI elements to trick the user into providing incorrect input. 
The lack of mouse support, which may appear only as functional limitation, exposes Fidelius to early form submission attacks. The host can emulate a mouse click on the submit button before the user completes all fields of a form.
%Not supporting mouse, may appear only as a functional limitation, but it exposes Fidelius to early form submission attack where the host can emulate a mouse click on the submit button while the user is in the process of typing into a text field. 
This allows the attacker to perform an early form submission with incomplete input - a violation of input integrity. Fidelius is also vulnerable to microarchitectural attacks on SGX enclaves~\cite{van2018foreshadow} that extract attestation keys and relay attacks~\cite{dhar2018proximitee} that redirects all user data to the attacker's platform.

The drawbacks of the existing systems show that ensuring the integrity and confidentiality of the IO in the presence of an untrusted host is a non-trivial problem and requires a comprehensive solution. All of the previous trusted path solutions neither protect both input and output simultaneously, nor do they consider different modalities of input. We discuss such drawbacks in details, along with some of the relevant solutions in Section~\ref{sec:problemStatement:existingSolution}.

 
\myparagraph{Our solution} The shortcomings of the existing literature provide the groundwork of our system named \name.
\name is built on the following observations: i) input integrity is possible only when both input and output integrity are ensured simultaneously, ii) all the input modalities are needed to be protected as they influence each other, and iii) high cognitive load results in user habituation errors. \name uses a trusted low-TCB auxiliary device that we call \device which works as a mediator between all user IO devices and the untrusted host. Instead of implementing a separate network interface, the \device uses the host as an untrusted transport - reducing attack surface.  
%\red{\device does not communicate with the trusted remote server directly. Instead, the \device uses the host as an untrusted transport.}

\emph{Integrity.} \name ensures \emph{output integrity} by sending an encoded UI to the host that only the \device can overlay on a part of the screen. The overlay is possible as the \device intercepts the display signal between the host and the monitor. The overlay generated by the \device ensures that the host cannot manipulate any output information on that overlaid part of the screen; hence, it can not trick the user. \device supports a subset of HTML5 UI elements that are frequently used in the majority of web applications. The \device focuses user attention on the overlaid part of the screen by dimming out the rest (also known as the lightbox technique which is one of the possible ways to focus user attention) when the user moves the mouse pointer on the overlaid UI. By doing so, \name aids the user to be more attentive to the security-critical UI on the screen. Note that \name does not require any change in the user interaction for IO integrity. Only the input devices that are connected to the \device can interact with the overlaid UI elements, making them completely isolated from the untrusted host. All the inputs are signed by the \device and sent to the remote server - ensuring input integrity.

\emph{Confidentiality.} \name provides IO confidentiality as i) all the input to the \device is encrypted and signed, and ii) the overlay information sent from the remote server is encrypted and can only be decrypted by the \device. However, the user needs to perform a small task such as triggering a secure attention sequence (SAS), or looking for a secret image, security indicator etc. to distinguish the trusted overlay.


\emph{Deployment.} \device is a fully plug-and-play device that is compatible with any host system regardless of their architecture or OS and does not require the user to install any software on the host. Note that our realization of \name uses an external device. However, the current system architecture can be modified, e.g., \device can be integrated into the graphics processor. 

\myparagraph{Our contributions} We now summarize our contributions:


\begin{mylist}
  \item \textbf{Identification of IO security requirements:} We identify new requirements for trusted path based on the drawbacks of the existing literature: i) unless both output and input integrity are secured simultaneously, it is impossible to achieve any of the two, and ii) without protecting the integrity of all the modalities of inputs, none could be achieved (Section~\ref{sec:problemStatement:existingSolution}).
  
   
  \item \textbf{System for IO integrity:} We describe the design of \name, a system that provides a remote trusted path from the server to the user, in an attacker-controlled environment. The design of \name leverages a small, low-TCB auxiliary device that acts as a \emph{root-of-trust} for the IO. \name ensures the integrity of the UI, specifically the integrity of mouse pointer and keyboard input. \name is further designed to avoid user habituation (Sections~\ref{sec:approach} and \ref{sec:systemDesign}).
  
  \item \textbf{System for IO confidentiality:} We also describe an extension of \name that provides IO confidentiality, where user needs to execute an operation like SAS to identify the trusted overlay on the display (Section~\ref{sec:confidentiality}).
  
   
  \item \textbf{Implementation and evaluation:} We also implement a prototype of \name and evaluate its performance (Sections~\ref{sec:prototype},~\ref{sec:eval}, and Appendix~\ref{appendix:implementation}).
\end{mylist}


%\myparagraph{Organization of the paper} The organization of this paper is as the following. Section~\ref{sec:problemStatement} provides the detailed motivation, problem statement, state-of-the-art and the goals of this paper. Section~\ref{sec:approach} provides the system \& attacker model, challenges and a brief overview of our solution. We discussed the technical details of \name in Section~\ref{sec:systemDesign}. Section~\ref{sec:securityAnalysis} provides in-depth security analysis of \name. Section~\ref{sec:prototype} and~\ref{sec:eval} provide details of \name prototype implementation and corresponding evaluation. Finally, Section~\ref{sec:relatedWorks} and~\ref{sec:conclusion} provides the related research works and concludes the paper respectively.
