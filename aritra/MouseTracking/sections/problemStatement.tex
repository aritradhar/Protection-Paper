\section{Problem Statement}
\label{sec:problemStatement}

In this section, we motivate our work in the context of ensuring integrity and confidentiality user's IO data to/from remote servers. We also describe selected existing research works that tackle the relevant problem, and we discuss how those works lack proper solution. Lastly, we explain the goals of this paper that we derive from the drawbacks of existing literature.

\subsection{Motivation: Secure IO with Remote Safety-critical System}

A user communicates with a remote server through a \emph{host} system that is typically a standard PC, which gives the host access to the plaintext IO data that is exchanged between the user and the remote server. The host consists of large and complex system software such as the modern operating systems, device drivers, etc., applications such as browser, and diverse set of hardware components that expose the host to a large attack surface. An adversary that controls the user's host can alter user intentions, i.e., it can perform arbitrary actions on behalf of the user, modify the input parameters, or show wrong information to the user. Such an adversary is very powerful and difficult to be detected or prevented by a remote server. The consequences of such attacks might be severe when applications that controls remote safety-critical systems are targeted. The attacker can pass the wrong input to a remote safety-critical system such as a medical device, power plant, etc.

Trusted execution environments (TEEs) enable remote trust into the code executing on the processor, effectively eliminating the need to trust more significant code base (motherboard, memory modules, OS and other applications). Processor TEE such as Intel SGX relies on the OS to mediate all the user IO. Hence, the problem of isolating user's input and output remains. Therefore, service providers typically operate with the assumption that the data they receive is genuine (generated by the user) and not altered by a compromised host. System-level TEEs such as ARM TrustZone allows implementation of privileged code like IO drivers inside the trusted environment. This is not possible in TEE architectures like SGX. But such a mechanism is limited to ARM platforms, making them infeasible for \emph{x86} platforms. %Despite such features usability issues such as security indicators, relying on secure boot, etc. to ensure IO integrity and confidentiality remain.


\begin{figure}[t]
\centering
%\includegraphics[trim={0 14cm 17cm 0}, clip, width=0.9\linewidth]{systemModel.pdf}
\includegraphics[trim={0 15cm 18cm 0}, clip, width=0.85\linewidth]{systemModel_all.pdf}
\caption{\textbf{Trusted path.} The figures shows the system and the attacker model of the trusted path. We generally consider two trusted path scenarios, \one trusted path to a remote server, and \two trusted path to a trusted execution environment (TEE) such as the Intel SGX.}
\spacesave
\label{fig:trustedPath}
\centering 
\end{figure}

In traditional settings, a \emph{Trusted path} provides a secure channel between the user and a trusted application running on the location host. Trusted path allows the user to ensure that her input is reaching to the intended application rather than a malicious one and the output is generated by the legitimate application. However, in the setting where the local host is fully compromised, trusted path to the local host is not possible as the trusted path requires a trusted endpoint, except if the local host supports TEE and runs an isolated enclaves on the local host. Establishing a trusted path to a remote server is non-trivial as the IO data is mediated by an untrusted operating system. Figure~\ref{fig:trustedPath} shows two different scenarios where the trusted path extends from user IO devices to \one a remote server, and \two a local enclave. %In principle, a trusted path solves the general security problem of the IO data. 
%But practically establishing a trusted path in general IO devices is a nontrivial problem specifically if one considers the plethora of complex UI objects and input methods as well as different security and functional properties that a solution should satisfy. 
In this paper, we primarily target the trusted path problem to a remote server (such as a remote PLC, web server or remotely accessible medical device, etc.) that is being accessed from a commodity $x86$ host.

\iffalse
\subsection{Security Properties}

A \emph{Trusted path} provides confidentiality and integrity to the IO data exchanged between the users and the end systems. In principle, a trusted path solve the general security problem of the IO data. But practically establishing a trusted path in general IO devices is a nontrivial problem specifically if one considers the plethora of complex UI objects and input methods as well as different security and functional properties that a solution should satisfy. We list these properties below. 


\begin{mylist}
  \item \textbf{Input integrity and confidentiality.} These properties define that any input that is coming from the user input devices are fully protected in two ways: i) the input issued by the user reaches to the remote end-point as it was generated by the user - \emph{integrity}, and ii) in specific application scenarios, the attacker-controlled host is entirely oblivious about the input from the user - \emph{confidentiality}. The trusted path system should consider a wide range of input devices, such as keyboard, mouse, touch, etc. We consider any sort of input action by the user that may include moving the mouse or using the keyboard navigation keys to select a specific item in a list.
  
  
  \item \textbf{Output integrity and confidentiality.} Similar to the input integrity, output integrity ensures that information that is sent by the remote endpoint is presented to the user as it was meant to be. One example of output integrity is the integrity of the UI elements. Such property ensures that the host system renders the UI elements faithfully as they were sent by the remote system. Output confidentiality ensures that the information sent by the remote server can not be accessed by the attacker-controlled host. 
  
 %  \item \textbf{Usability.} The trusted path should neither change the typical user interaction with a computer nor should require extensive changes into the existing systems.

  As discussed on the Section~\ref{sec:securityAnalysis}, ensuring output integrity is essential for providing input integrity against advanced attackers that trick the user into sending non-legitimate data to the server. For example, the user wants to send a number \texttt{10} to the server, but the malicious host shows on screen \texttt{100} and fools the user into believing he mistyped a \texttt{0}. The user deletes one \texttt{0} and sees \texttt{10} on the screen---as he intended initially---and submits the data, however, on the server arrives just \texttt{1}. 
  
  Providing output integrity is a challenging task even on systems that have a trusted component that overlays parts of the HDMI frames generated by the untrusted host. Previous works~\cite{huang2012clickjacking} show that when a trusted component and an untrusted one share a screen, the attacker can still manipulate the user to commit unintentional actions to the trusted UI if the system is not designed properly. In our solution we want to guarantee that the user is aware of the UI elements (trusted or untrusted) that she interacts with, therefore preventing related attacks.
  \end{mylist}

\fi




\subsection{Existing Solutions and their drawbacks}
\label{sec:problemStatement:existingSolution}

\iffalse
\begin{figure}[t]
\footnotesize
    \centering
    \begin{tikzpicture}[
solved/.style={rectangle,draw,fill=purple!40, rounded corners, align=center},
not/.style={rectangle, draw,fill=orange!60, rounded corners, align=center},
neutral/.style={rectangle, draw, rounded corners, align=center, fill=black!5}
]]
    \node[neutral](root) {Trusted path}
    child { node[neutral, yshift=12pt] (hw) {External\\ HW}}
    child { node[neutral, yshift=8pt, xshift=10pt] (tc) {Transaction\\ confirmation\\ Device}}  
    child { node[neutral, yshift=12pt, xshift=20pt] (tee) {TEE}
      child { node[neutral, yshift=0pt, xshift=-5pt] (teehv) {Hypervisor+\\TEE}}
      child { node[neutral, yshift=0pt, xshift=2pt] (teehw) {TEE + \\ External HW} } }
      child { node[neutral, yshift=8pt, xshift=15pt] (br) {Browser\\ Based}}   
     child { node[neutral, yshift=12pt, xshift=20pt] (hv) {Hypervisor}}  ;
    
    \node[below=0cm of hw] {\textbf{\name}};
    \node[below=0cm of tc] {Uni-dir~\cite{filyanov2011uni}};
    \node[below=0cm of hv] {Overshadow~\cite{Overshadow}};
    \node[below=0cm of teehv] {SGXIO~\cite{weiser2017sgxio}};
    \node[below=0cm of teehw] {Fidelius~\cite{Fidelius}};
     \node[below=0cm of br] {InContext~\cite{blake1998authenticated}};    
    \end{tikzpicture}
    
   \caption{\textbf{Summarization of existing trusted path solutions} by their approach. A detailed description of the related works is discussed in Table~\ref{tab:relatedWorks}.}
     \label{fig:relatedWorksTree}
\end{figure}
\fi





There exist two broad categories of existing solutions that address the problem of trusted paths for IO devices in the presence of a compromised host as illustrated in the graph of Figure~\ref{fig:relatedWorksTree}: \textbf{A.} Solutions where unprotected user interaction first happens and then a trusted component (transaction confirmation device) is used to double check that manipulation did not happen, and \textbf{B.} Solutions where a trusted component that can capture user's input/output and then securely mediate it to the destination. The trusted component can be a browser, hypervisor, external hardware, etc. %But all of these solutions targeted for different problem settings and models. 
%Figure~\ref{fig:relatedWorksTree} provides a board classification of the related works and illustrates where our proposed work stands concerning them. %We can generally classify the work into two broad categories based on the trusted path approaches transaction confirmation device and existence of other trusted components.

\myparagraph{A. Transaction confirmation devices} In their paper, Filyanov et. al~\cite{filyanov2011uni} proposed transaction confirmation device that requires the user to use a separate device to confirm the input parameters. Systems such as ZTIC~\cite{weigold2011secure} uses external device with display and smartcard attachment to confirm inputs. Android OS also provide similar~\cite{android_confirm} mechanism to confirm protected transactions. The transaction confirmation suffers from three significant drawbacks. The first drawback is risk of \emph{user habituation}. Transaction confirmation device introduces lots of cognitive load over the user and may force the user to confirm their action without even looking to the input data. The second \emph{usability}, i.e., interacting with a small device can be cumbersome. Such user action makes the transaction confirmation device impractical in day-to-day interactions. Finally \emph{simple UI}, i.e., transaction confirmation is not practical/suitable for complex interaction, rather simple text-based inputs. 

%In contrary, \name supports generic input devices and supports complex user interfaces and user interactions. Moreover, the complete automated nature of \name does not introduce any cognitive load on the user, making the system less susceptible to user error.

\begin{figure}[t]
\scriptsize
    \centering
    \begin{tikzpicture}[
solved/.style={rectangle,draw,fill=purple!40, rounded corners, align=center},
not/.style={rectangle, fill=white, align=center},
neutral/.style={rectangle, draw, rounded corners, align=center, fill=black!5}
]]
  \node[not](empty) {};
    \node[neutral, right=3cm of empty](root) {Trusted path}
    child { node[neutral, yshift=10pt, xshift=-70pt, yshift=10pt] (tc) {\textbf{A.} Transaction\\ confirmation Device}}  
    child { node[neutral, yshift=10pt, xshift=10pt, yshift=15pt] (td) {\textbf{B.} Trusted intermediary}       
        %child { node[neutral, yshift=0pt, xshift=-30pt, yshift=7pt] (tee) {\textbf{B2.} TEE}}
      child { node[neutral, yshift=2pt, xshift=-50pt, yshift=7pt] (br) {\textbf{B1.} Browser-based}}   
     child { node[neutral, yshift=2pt, xshift=-25pt, yshift=7pt] (hv) {\textbf{B2.} Hypervisor-based}} 
     child { node[neutral, yshift=2pt, xshift=0pt, yshift=7pt] (hw) {\textbf{B3.} External HW}}
    } ; 
      

    \node[below=0cm of hw](gurdion) {\textbf{\name}};
    %\node[below=0cm of tee] {VButton~\cite{li2018vbutton}};
    \node[below=0cm of tc] {Uni-dir~\cite{filyanov2011uni}};
    \node[below=0cm of hv](os) {Overshadow~\cite{Overshadow}};
    \node[below=0cm of os] {SGXIO~\cite{weiser2017sgxio}};
    \node[below=0cm of gurdion] {Fidelius~\cite{Fidelius}};
     \node[below=0cm of br](ic) {InContext~\cite{blake1998authenticated}};
     \node[below=0cm of ic] {W3C UI security policy~\cite{w3c_spec}};

    
    \end{tikzpicture}
    
   \caption{\textbf{Existing trusted path solutions} by their approach. A detailed description of the related works is discussed in Table~\ref{tab:relatedWorks} in Appendix~\ref{appendix:summaryResearch}.}\spacesave
     \label{fig:relatedWorksTree}
\end{figure}

%None of these works looked into complex user interactions such as mouse movement or complex user interfaces. 


%\myparagraph{B2. Trusted Execution Environments} TEEs specifically system TEEs such as ARM TrustZone is used in the literature to implement a trusted path between the IO devices and the users. VButton~\cite{li2018vbutton} leverages ARM TrustZone to overlay buttons on the mobile device to confirm if the user taps on a specific button. Our solution is fundamentally different from VButtion as i) VButtion is specifically tuned for mobile devices, employing ARM TrustZone whereas our solution is more generic and targets specifically PCs, and ii) mouse input is significantly different than touch-based input as mouse input involves continuous movement where the touch or taps are discrete events. In this paper, we concentrate on the non-specialized hardware platform where compatible TEE technologies such as ARM TrustZone may not be available, e.g., x86 architecture. 
%Intel SGX based trusted path such as BastionSGX~\cite{BASTION-SGX} implements a trusted Bluetooth application inside an Intel SGX enclave to establish a trusted path between the keyboard and mouse and the SGX. But lack of output integrity makes the system unreliable as the paper failed to address how to transfer the mouse data reliably to the user and the remote server. 

\myparagraph{B1. Browser-based solutions} InContext~\cite{huang2012clickjacking} presents different clickjacking attacks variants and their solution by ensuring context (both temporal and visual) and pointer integrity. W3C UI security specification~\cite{w3c_spec} also recommends the developers to annotate the security-critical UIs so that the browser can enforce no JS can draw objects on top of it. Clickjacking Revisited~\cite{akhawe2014clickjacking} provides such security measures in the context of a trusted browser. The browser-based solutions assume that the browser is fully trusted, hence, these solutions incur higher TCB. And in a compromised host scenario, such mechanisms does not work.
%The trust model is significantly different from our work as it assumes that the browser and the OS are trusted. This makes the InConext i) not directly compatible with the attacker model that \name targets, and ii) targets a specific attack scenario (clickjacking vs. generic trusted path).


\myparagraph{B2. Trusted hypervisor-based solutions} Trusted hypervisors and secure micro-kernels are also alternatives to achieve Trusted path. In work done by Zhou et al.~\cite{zhou2012building}, the authors proposed a generic trusted path on $x86$ systems in pure hypervisor-based design. Solutions such as SGXIO~\cite{weiser2017sgxio}  combine a TEE and a hypervisor to mitigate the shortcomings of TEEs like SGX (i.e., the IO operations are handled by the OS). One major drawback of such solutions is the trust assumption that involves a full hypervisor. One can argue that a hypervisor that provides a rich set of functionalities has code base size of an OS. Second, most of the minimal hypervisor also does not offer common usable features such as rich IO, UI, etc., making them impractical for day-to-day usage in consumer devices. TEEs such as SGX also open up new attack surfaces such as microarchitectural attacks~\cite{van2018foreshadow}.

%There exist several works that use TEE and hypervisor simultaneously to mitigate the shortcomings of TEEs like SGX (i.e., the IO operations are handled by the OS). Existing research such as SGXIO~\cite{weiser2017sgxio} requires the IO drives to be implemented inside the TEE or using trusted hypervisor that extends the size of the TCB significantly. Moreover, TEE requires trust assumption on the processors and additional code bases. One such example is Intel SGX where the trust model includes the physical processor package, SGX SDK, quoting enclave, launch enclave and Intel attestation service. Our proposed solution avoids such extensive trust assumptions and assumes that the entire platform is in control of the attacker.



%In summary, even though, there exist several research works that look into the problem of the trusted path, none of them provide a complete, secure, practical and usable trusted path solution. In our knowledge, \name incorporates all the features together for the first time: complex user interactions and UI elements, generic IO devices and low overhead on the user interactions. All of these are achieved in the smallest trust assumption.  

%Note that the majority of the previous works achieve some form of trusted path specifically for keyboard-based input. However supporting mouse and touch-based input, complex and generic user interfaces and protected users' action (such as the movement of the mouse pointer, gestures, etc.) in a security-sensitive application (such as e-voting) is not a trivial task. Without proper analysis of every frame that the host system produces, it is not possible to track user intention. In our knowledge, our proposed solution is the first to provide such security properties including the confidentiality of user input (e.g., mouse movement). Moreover, we want to achieve this in the absence of any TEE as the trust model of our scenario is significantly different.

%Detailed description of the related research is described in Table~\ref{tab:relatedWorks} in Appendix~\ref{sec:summaryResearch}.

\myparagraph{B3. External hardware-based solution} Several existing works propose trusted path that utilizes an external trusted device. One of the recent solution is Fidelius~\cite{Fidelius} that provides the most comprehensive solution. Fidelius uses an external trusted device and Intel SGX to create a secure channel between the user IO devices and a remote server. Fidelius provides secure input and display for the character-based device - keyboard. It uses overlays on the text fields to hide the keyboard input from the compromised host so that the input is only visible to the user. A small bar on display is also overlaid by the device that shows the remote server's identity and the text field that is currently selected. However, Fidelius suffers from the following security and functionality issues: 
\vspace{-0.5em}
\begin{mylist}
\item Fidelius only overlays the text fields and the character inputs into those text fields. This allows the attacker to modify the instruction on the UI, such as changing the unit of the input (mentioned in the label of the text field) that results in an incorrect input. Fidelius solely relies on the static overlay region and the LEDs on the external device to ensure the integrity and confidentiality of the input. This introduces a high cognitive load on the users as the user needs to check for three security indicators simultaneously before filling up one text field. Existing research works~\cite{egelman2008you,sobey2008exploring} show that in real-world, passive security indicators that require the users to observe multiple markers on the screen (and also on an external device) do not provide adequate security and the systems that implement them suffer from user habituation. Reliance on the user to check the security indicators makes Fidelius as unsafe as transaction confirmation devices (\textbf{A}). 
The cost of deployment of such system is high as the system requires the user to familiarize with the aforementioned security indicators 
\item As Fidelius does not support the integrity of the mouse pointer and its interaction with UI elements, this allows the OS to trigger a mouse click on the submit button on the form and force sending incomplete data to the server. Thus, the OS could compromise the integrity of the input data. 
\item As the mouse pointer is not protected, Fidelius is vulnerable to clickjacking attack where the attacker can spawn multiple mouse pointers and trick the user into following a wrong mouse pointer while the real mouse pointer is on the sensitive text field. This allows the attacker to trick the user into providing (possibly incorrect) input, while the user thinks that she is interacting with a non-sensitive text field. To prevent such attacks, the user has to look at the security indicator consistently even when she is not doing any security-sensitive task which is not a realistic assumption. 
\item The design of Fidelius is strictly limited to text fields only. As Fidelius does not provide output integrity of the forms, it can not provide confidentiality to other UI elements such as radio buttons, drop-down menus, etc.
\item Recent microarchitectural attacks on SGX~\cite{van2018foreshadow} increase the attack surface on the systems such as Fidelius that rely on SGX for security against malicious OS and applications. 
\end{mylist}

\subsection{Goals}
\label{sec:problemStatement:goals}

The lack of security properties and features in the existing solutions provide the scope of our paper where we targets the following goals:

\begin{mylist}
  \item  \textbf{Rich set of IO security features.} Most of the existing trusted path solutions focus on a minimal set of feature (e.g., only support for keyboard). The primary goal of \name is to be compatible with generic IO devicew (such as a keyboard, mouse, touch screen, display, etc. in x86 architecture), and complex UI elements \& user interactions that are common in today's web e.g., drop-down menus, radio-buttons, etc. 
  
  \item  \textbf{Small trust assumption.} Our goal is to provide the aforementioned rich set of IO and security features with minimal trust assumption that does not rely on a specialized hypervisor or a trusted OS  or TEEs such as Intel SGX. %Rather \name only trust a plug-and-play small-TCB trusted device that is made out of off-the-shelf components.  
  

  
  \item \textbf{Low cognitive load.} \red{Our goal is not to change the way users interact with UI elements and to impose no or minimal cognitive load such as eliminating the need to see an external device to confirm every transaction, looking to a passive security indicator and confirming actions, etc. The systems that rely heavily on such security measures suffer from input errors that originate from user habituation. Moreover such designs requires heavy user training that makes the system deployment hard and costly.}
  
    \item \textbf{Ease of deployment.} Our goal is also to provide a solution that comes with low deployment overhead such as eliminating any design choices that requires user training, a plug-and-play device that uses off-the-shelf components, the solution is compatible with any platform (OS, processor architecture, etc.), and does not require to install additional applications in the host.

\end{mylist}

%In the following section what follows is the \name's design and how \name achieves these goals.
