\section{Related Works}
\label{sec:relatedWorks}


In this section, we provide outline of existing research works that targets the problem of securing IO. Table~\ref{tab:relatedWorks} in Appendix~\ref{appendix:summaryResearch} presents a summary of existing works and position of \name with respect to them.



\subsubsection{Trusted hypervisor/OS-based solutions} Trusted hypervisors and secure micro-kernels are also choices for contrasting Trusted path. Sel4~\cite{klein2009sel4} is a functional hypervisor that is formally verified and has a kernel size of only $8400$ lines of code. In work done by Zhou et al.~\cite{zhou2012building}, the authors proposed a generic trusted path on $x86$ systems in pure hypervisor-based design. Examples of other hypervisor-based works can be found in systems such as Overshadow~\cite{Overshadow}, Virtual ghost~\cite{criswell2014virtual}, Inktag~\cite{hofmann2013inktag}, TrustVisor~\cite{mccune2010trustvisor}, Splitting interfaces~\cite{ta2006splitting}, $SP^3$~\cite{yang2008using}, etc.

In their paper InContext, author Huang et al.~\cite{huang2012clickjacking} presents different clickjacking attacks variants and their solution by using ensuring context (both temporal and visual) and pointer integrity. The pointer integrity is maintained by capturing the screenshot of the UI elements around the pointer and verify with a baseline render of the legitimate UI. The trust model is significantly different from our work as it assumes that the browser and the OS are trusted. Such an attacker model makes the continuous tracking of the pointer unnecessary. Moreover, the clickjacking attack focuses on the cases where the JS served from an untrusted web server tricks the user into clicking on a browser rendered UI (such as the microphone/web camera permission widget that is out of control of the JS). In our case, as we assume the OS/browser to be untrusted, the host can execute arbitrary modification on display. This makes the InConext not directly compatible with the attacker model that \name targets. In summary, InContext looks into some of the properties that \name ensures, namely the context of the user and the pointer integrity but in a completely different problem statement (clickjacking vs. trusted path) and trust assumption.

\subsubsection{Trusted Execution Environments} TEEs are other ways to implement a trusted path between the IO devices and the users. Several TEEs such as Intel SGX, ARM TrustZone, TPM, Intel TXT, etc. can be used to achieve such functionality. Previous research works such as Intel SGX and trusted hypervisor-based SGXIO~\cite{weiser2017sgxio}, Intel SGX based ProximiTEE~\cite{dhar2018proximitee}, TPM and TXT based trusted path~\cite{filyanov2011uni}, and ARM TrustZone based trusted path~\cite{filyanov2011uni,sun2015trustotp} are the example of trusted path construction based on TEEs. All of these solutions require specialized platforms with processors that support such infrastructure. In our proposed solution, we concentrate on the non-specialized hardware platform where compatible TEE technologies may not be available. VButton~\cite{li2018vbutton} uses ARM TrustZone to overlay buttons on the mobile devices that conforms if the user taps on certain buttons. Our solution is fundamentally different from VButtion as i) VButtion is specifically tuned for mobile devices, employing ARM TrustZone where as our solution is much generic and targets specifically PCs, and ii) mouse input is significantly different than touch based input as mouse input involves continuous movement where the touch, or taps are discrete events.

TEE primarily provides execution privacy and code integrity. In most of the cases, IO is still mediated by the OS. To mitigate this, may existing research (SGXIO~\cite{weiser2017sgxio}) requires the IO drives to be implemented inside the TEE or using trusted hypervisor that extends the size of the TCB significantly. Moreover, TEE requires trust assumption on the processors and additional code bases. One such example is Intel SGX where the trust model includes the physical processor package, SGX SDK, quoting enclave, launch enclave and Intel attestation service. Our proposed solution avoids such extensive trust assumptions and assumes that the entire platform is in control of the attacker.

\subsubsection{Browser-based solutions} In their paper InContext, author Huang et al.~\cite{huang2012clickjacking} presents different clickjacking attacks variants and their solution by ensuring context (both temporal and visual) and pointer integrity. The pointer integrity is maintained by capturing the screenshot of the UI elements around the pointer and verify with a baseline render of the legitimate UI. The trust model is significantly different from our work as it assumes that the browser and the OS are trusted. Such an attacker model makes the continuous tracking of the pointer unnecessary. Moreover, the clickjacking attack focuses on the cases where the JS served from an untrusted web server tricks the user into clicking on a browser rendered UI (such as the microphone/web camera permission widget that is out of control of the JS). In our case, as we assume the OS/browser to be untrusted, the host can execute arbitrary modification on display. This makes the InConext not directly compatible with the attacker model that \name targets. In summary, InContext looks into some of the properties that \name ensures, namely the context of the user and the pointer integrity but in a completely different problem statement (clickjacking vs. trusted path) and trust assumption.

\subsubsection{Dedicated hardware-based solution} Previous research works such as IntegriKey~\cite{IntegriKey} uses a low-TCB embedded device to introduce a second factor for input integrity. Similar solutions exits such as transaction confirmation devices~\cite{filyanov2011uni} that uses a small display device to show the input parameters to the users.
Such systems are oblivious to the context of the users and the display device hence attacks where attacker selectively drop characters from the text-field are hard to mitigate.  
Fidelius~\cite{Fidelius} uses raspberry pi's and Intel SGX to create a secure channel between the keyboard and the display device. By doing so, Fidelius provides secure input and display for the character-based device - keyboard. Additionally, Fidelius uses overlay to hide the keyboard input from the compromised host so that the input is only visible from the user. In their work, Brandon et al. ~\cite{brandon2017trusted} demonstrate screen overlay on Android devices using FPGAs.

Note that majority of the previous works achieve some form of trusted path specifically for keyboard-based input. However supporting mouse and touch-based input, complex and generic user interfaces and protected users' action (such as the movement of the mouse pointer, gestures, etc.) in a privacy-sensitive application is not a trivial task. Without proper analysis of every frame that the host system produces, it is not possible to track user intention. In our knowledge, our proposed solution is the first to provide such security properties including the mouse movement privacy. Moreover, we want to achieve this in the absence of any TEE as the trust model of our scenario is significantly different. 
