\section{Approach Overview}
\label{sec:approach}



\begin{figure}[t]
\centering
\includegraphics[trim={0 6cm 17cm 0}, clip, width=0.85\linewidth]{approachOverview.pdf}
\caption{\name: approach overview.  The \device connects the IO devices and the attacker-controlled host.}
\label{fig:approachOverview}
\centering
\end{figure}

Given the problem statement discussed in Section~\ref{sec:problemStatement}, we first define the attacker model we consider in our proposed system.


\subsection{Attacker Model}

We assume the highly adversarial scenario where the attacker compromises the host system completely (OS, installed applications and hardware). The attacker also controlled the network. We only assume that it is a PPT-attacker, so he can not break crypto. Figure~\ref{fig:systemModel} shows the components of the system that are controlled by the attacker, i.e., the host and the network communication channel between the host and the remote server.

We only assume that the monitor, keyboard, mouse and the \device are trusted. Which is not unrealistic. The monitor, keyboard, and mouse have hardly any complex hardware. The TCB is very small.

\subsection{Challengers}

Modern user interfaces are extremely complex to analyze, and such allows many possible ways to provide input. This makes the protection of IO integrity, and privacy is a particularly challenging task. For example, given a command from the user, it is necessary to understand the user intention that corresponds to the mouse movements. Given the screen space, there exist unbounded ways for the user to move a mouse a place it on a specific UI element that fires a command to the remote end system. To provide an end-to-end protection to this entire activity one needs to 1) precisely track the cursor position, 2) correspond the cursor location to the given movement data from the mouse, 3) understand the semantics of the UI element the fires the command and 4) generate an efficient and comprehensive proof that server can use to understand the user's real intention.  


\subsection{Approach}

The overall approach is illustrated in Figure~\ref{fig:approachOverview} that utilizes a low TCB embedded device. The embedded device acts as a bridge between all IO devices and the attacker-controlled host. The device works as a second factor for user IO data. In a high level, the remote server and the device establishes a secure channel using the untrusted host as a transport. Note that the low-TCB device does not have any explicit network capabilities. The server also adds a small JavaScript snippet that allows the device and the remote server to communicate. This eliminates any need for additional hardware/software aids.


All the input from the user is intercepted by the device, specifically the mouse pointer and keyboard. The device intercepts the raw mouse data from the user, and on the screen, it detects the corresponding position of the mouse pointer. The device captures a trace of the mouse pointer position and the click data. Using the mouse trace data, the device computes a proof-of-pointer. The proof-of-pointer serves as an indirect measure for the input integrity as the device confirms the remote server that if the user drags/clicks the mouse in a way that results in an input to the remote server. Direct inputs such as clicking a button or a text data in a text box are signed by the device and sent to the remote server. These signed input data serves as the second-factor fort the input integrity. The server receives and matches the \emph{applications-level} payload from the browser and the \emph{signed second factor} from the device. 


The JavaScript snippet that is served by the remote server transforms the security-critical part of the webpage to a QR-code encoded specification. The device detects the QR code by intercepting the HDMI frame between the host and the display device. The specification is signed that provides the integrity and the authenticity of both the output data and the UI objects on the webpage. 

