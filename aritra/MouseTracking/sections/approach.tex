\section{\name Approach Overview}
\label{sec:approach}


\begin{figure}[t]
\centering
\includegraphics[trim={0 8.5cm 17cm 0}, clip, width=0.85\linewidth]{approachOverview.pdf}
\caption{\textbf{High-level approach overview of our solution.}  The \device connects the IO devices and the attacker-controlled host. We also assume that the network is also attacker-controlled.}
\spacesave
\label{fig:approachOverview}
\centering
\end{figure}


In this section, we present an overview of \name: our proposed solution. \name provides a trusted path between the user IO device and the remote server by utilizing a trusted embedded device (B1 in Figure~\ref{fig:relatedWorksTree}) as a mediator between all the IO devices and the untrusted host. We call this device: \device. The approach, on the high-level, uses the concept of the \emph{bump in the wire}~\cite{McCPerRei2006} to provide integrity and confidentiality to the user IO actions.  %The server also adds a small JavaScript snippet that allows the \device and the remote server to communicate. This eliminates any need for additional hardware/software aids.

We first define the system and attacker model, then outline the challenges and the brief outline of our proposed solution.

%Given the problem statement discussed in Section~\ref{sec:problemStatement}, we first define the attacker model we consider in our proposed system.


\subsection{System and Attacker Model}


We consider a system model where the user wants to sends the input to a safety-critical remote end-system. The model is depicted in Figure~\ref{fig:approachOverview} that shows the untrusted host, remote server and the user IO devices. 

We assume that the attacker controls the host system completely (OS, installed applications and hardware). The attacker also controls the network. %We assume that the attacker is a probabilistic polynomial time (PPT) algorithm that can not break crypto. 
Figure~\ref{fig:approachOverview} shows the components of the system that are controlled by the attacker, i.e., the host and the network communication channel between the host and the remote server.

We only assume that the monitor, keyboard, mouse (in a word all the IO devices that we need to protect from the malicious host) and the \device are trusted.
%which is not unrealistic. The monitor, keyboard, and mouse have hardly any complex hardware. The TCB is very small.

The \device works as a mediator between all the IO devices and the host. Note that the \device has no network capability to communicate with the server, rather it relies on the host and use it as an untrusted transport. We also assume that the \device comes with some embedded certificates and keys that allow the \device to verify the signatures signed by the server and sign statements such as the user input. We can assume that the \device is issused by a service provider who also runs the remote server.

\myparagraph{Attacker's capability} As the host is attacker-controlled, it can intercept, drop or modify the user IO data to and from the remote server.On top of it, the host can launch complex UI-based attacks. Such includes spawning multiple mouse pointer to trick the user into following the wrong mouse pointer, changing the layout of the UI elements to trick the user into providing sensitive data, tricking the user into moving the mouse to the wrong location and click there, manipulate input data, etc.

\iffalse
\begin{figure}[t]
\centering
\includegraphics[trim={0 13cm 21.7cm 0}, clip, width=0.65\linewidth]{screenPartition.pdf}
\caption{\textbf{\device's pointer tracking, pointer \& UI overlay, and security properties.} Our proposed method provides two layers of protection for IO to the user. 1. In all the parts of the screen, the \device provide pointer integrity (the gray part). 2. The green part of the screen where the \device overlays on the HDMI stream where the \device provide integrity and privacy (privacy is dependent on the application requirements) for the IO.}
\spacesave
\label{fig:screenPartition}
\centering
\end{figure}
\fi


\subsection{Strawman solutions for IO integrity}
\label{sec:approach:strawman}

\begin{figure}[t]
\centering
\includegraphics[trim={0 13.5cm 11.5cm 0}, clip, width=\linewidth]{uiDetect_2.pdf}
\caption{\textbf{Strawman solution: Text/Image Analysis of the UIs}. This strawman solution uses image/text analysis to detect the UI element leveraging edge detection and optical character recognition (to extract the labels on the UI element). The solution suffers from lack of robustness where the \device sometime fails to correctly classify the UI elements/labels due to mouse position or colors.}
\label{fig:uiDetect}
\centering
\end{figure}

Here we explain two strawman solutions by which the \device confirm that the user executes certain action, e.g., clicking a button  or selecting an option from a drop-down menu and ensures that the user views legitimate UI.


Note that the \device sits between all the IO devices and the host. This enables the \device to intercept the HDMI interface. As soon as the user executes an action, e.g., clicking the mouse, the \device takes a snapshot of the screen and send the snapshot to the server using the TLS upstream channel (Section~\ref{sec:systemDesign:confidentiality:tls}. Along with the snapshot, the \device also transfers the timestamp for later verification. The user input data, snapshot, and the timestamp from the \device generate the proof that the user executes certain activities. Note that, this strawman solution primarily serves as an offline audit. One use case scenario is a bank where the signed transcript can be later used to solve transaction dispute. 

This making of taking screenshot of UI elements an also be transformed into online verification by using the image and text analysis to extracts the information from the UI elemets. Such as the label on a button or the markers on a slider, etc. In Figure~\ref{fig:uiDetect} we illustrate an example scenario where the \device extract the context of the mouse position when a user clicks. This involves the \device to take a truncated screen-shot from the HDMI frame and use image analysis to understand user action. E.g., in Figure~\ref{fig:uiDetect}, \one the user first drags along the slider UI to set a value (\texttt{35}) and then \two the user clicks on the \texttt{OK}. The \device uses character recognition technique to extract the label and the data from the UI. This example shows the apparent complexity of this mechanism that does not scale with all UI. Further investigation and prototype implementation shows several drawbacks of this solution:


\begin{mylist}
  \item \textbf{Incomplete user context.} The proposed method failed to capture the complete context of the user input. Capturing the UI element only around the mouse pointer ignore the input values that are provided by the user. For example, the use may press \texttt{OK} button after providing the sensitive data, but to capture those data, the \device needs to capture more screen area. Such a method would complicate the entire process and does not generalize.
  \item \textbf{Robustness.} Previous research works such as as~\cite{lukaSpoof,Chen:2010:DVS:1754393.1754394} propose detection of a phishing attack by visually analyzing the web interface of the mobile applications. All of these proposed methods fail to achieve 100\% accuracy in the real world scenarios. Our prototype implementation also confirm that the method lacks robustness in real life as most of the time the \device fails to either recognize the UI elements or extract the label from the UI elements properly despite of using state-of-the-art image/text analysis tools~\cite{opencv}. More importantly, adversarial machine learning techniques~\cite{eykholt2017robust,sitawarin2018rogue} could make the image/text recgnition technique insecure.
  \item \textbf{Performance.} The image/text analysis is CPU intensive and causes a low number of frame output by the \device. Commonly used image analysis frameworks such as OpenCV~\cite{opencv} is CPU intensive and it hard to achieve $24$ fps after the operation on the \device that is implemented on an ARM-based Raspberry Pi.
  \item \textbf{TCB.} The image/text analysis functions are needed to be implemented either on the \device or the remote server. Such increases the size of the TCB significantly.
  \item \textbf{Privacy.} Taking the screenshot also reveal other applications that the user is operating which can be a threat to privacy.
\end{mylist}

Due to such limitations, and the inherent offline nature of this solution, we developed more efficient solution to preserve the integrity of user actions on a UI element. We describe the method in the following section. The solution has a trade-off that the developers need to incorporate some small changes to the remote server but provides better security and usability. We describe our solution in the following section.

\subsection{High-level Description of the System}

\begin{figure}[t]
\centering
\includegraphics[trim={0 8cm 20cm 0}, clip, width=0.9\linewidth]{overlayScreenShot.pdf}
\caption{\textbf{\device generated UI overlay} The figure shows the \name high-level approach. \one shows the non-protected part of the screen where the Ui is rendered by the untrusted host. \two shows the \device generated protected UI overlay that is hidden from the host. The protected part of the screen provides integrity and confidentiality of all user IO.}
\spacesave
\label{fig:screenshot_1}
\end{figure}

%\myparagraph{Components} \name assumes that IO devices (mouse, keyboard, and display) are connected to a trusted component called \device. This setup allows the trusted \device to receive raw inputs from the user and show overlays on display. The goal of \name is to keep the code running on the \device minimal and at the same time support a wide variety of applications. Thus, we avoid running any application, such as browsers, on the trusted component to keep the TCB very small.

\myparagraph{Key idea} %\red{The key idea of \name is to introduce \emph{root-of-trust} for the IO devices that provides trusted path to remote servers. This is achieved by the \device that provide proof for integrity and confidentiality for all user IO. Thus making the IO devices trustworthy to the users. }
The overall approach is illustrated in Figure~\ref{fig:approachOverview}. On a high level, the remote server and the \device establishes a secure channel using the untrusted host as a transport. Note that the \device does not have any network capabilities, instead uses the host as an untrusted transport.
The \device operates in two modes: passive and active. In the passive mode, the \device serves as a relaying device that forwards mouse and keyboard inputs to the host. Similarly, the \device relays the HDMI frames from the host to the display. Hence, the user experience is not affected when interacting with regular applications. On the active mode, \device has two functionalities: i) intercepts the inputs generated by the user, and ii) render overlays on the HDMI frame that is displayed on the screen. 
The first functionality guarantees that the user inputs arrive directly to a trusted component (\device); therefore, the compromised host cannot manipulate them. The second functionality allows the \device to show trusted information on the screen such as input elements, or data sent from the remote server. A naive solution would be running an entire OS and browser from the \device that provides isolation from the attacker-controlled host. Such approach makes the size of the \device TCB massive, making it to be as vulnerable as the host. 

During the initialization phase, the \device and the remote server share a key that is used to encrypt/sign the communication between each other. The remote server signs the sensitive elements that should be protected and delivers them to the untrusted host. The application running on the host encodes the sensitive elements into the HDMI frame. The \device captures the frames, decodes the sensitive elements, verifies their signatures, and then renders elements into an overlay. Figure~\ref{fig:screenshot_1} provides a screenshot of attacker's view of the screen and the user's view after the \device overlays the UI. \one shows non-sensitive elements that are unprotected, while \two are the protected elements that are not rendered by the untrusted host. In this way, the device guarantees that the user is presented with the legitimate elements sent by the remote server and the user interaction with these elements is managed only by the device itself. Note that the device renders only the protected input elements, while other UI components of the application are rendered by the host. 
Therefore, user inputs (mouse events and keystrokes) addressed to the protected elements are intercepted by the \device and not forwarded to the untrusted host. Furthermore, the \device renders on runtime the user inputs into the overlay while the host is oblivious about them. From the user's perspective, the workflow of filling a form with protected elements remains the same as filling forms of existing applications.


\subsection{Challenges}

%Modern user interfaces are extremely complex to analyze, and such allows many possible ways to provide input. This makes the protection of IO integrity, and privacy is a particularly challenging task. For example, given a command from the user, it is necessary to understand the user intention that corresponds to the mouse movements. Given the screen space, there exist a multitude of ways for the user to move a mouse a place on a specific UI element that fires a command to the remote end system. To provide an end-to-end protection to this entire activity one needs to 1) precisely track the cursor position, 2) correspond the cursor location to the given movement data from the mouse, 3) understand the semantics of the UI element the fires the command, and 4) generate an efficient and comprehensive proof that the server can use to understand the user's real intention.

Modern user interfaces (UIs) are diverse and hard to generalize, resulting in many possible ways to provide input and receiving output.  This makes the protection of IO integrity, and confidentiality is a particularly challenging task. For example, given a mouse movement and clicking on a button from the user, it is necessary to understand the user intention that corresponds to the mouse movements. 
%One naive solution would be to record a continuous screen capture of display and send it to the server. As the screen capture captures all the information displayed on the screen, later review should uncover if the attacker attempts to manipulate the UI or the IO data. Even though this naive solution provides strong security guarantee, it is impractical. So, the first challenge arises to build a secure system that is feasible and can be generalized with all the IO devices.   

The second challenge arises while ensuring IO confidentiality. For mouse input, hiding the mouse movement while keeping all the regular functionality intact is a challenging task as we do not consider large TCB-based solution such as a trusted hypervisor.


Apart from these functional challenges for implementation, there exist multiple attack vectors that we want to provide protection. 


\iffalse
\subsection{Approach}

The main objective of our approach is to provide a secure channel between the user IO devices and the remote server that provides integrity and privacy of the IO data. Our solution uses the \device as the IO \emph{root-of-trust}. The \device that can be either integrated into the graphics card or can be used as a stand-alone auxiliary device (as we did in our implementation). The \device taps into the HDMI channel extract frames and determine the current context of the user's action. The \device also can overlay bitmaps into the HDMI channel. By doing this, the \device provides security properties to the IO devices that are illustrated in Figure~\ref{fig:screenPartition}. Using such capability, our system provides the following security properties: \emph{\pop}, \emph{\poui}, \emph{\poa}, and integrity and privacy of the IO.

\myparagraph{\Pop} All the keyboard and mouse input from the user is intercepted by the \device. The \device uses the raw mouse data from the user, and on the screen, it detects the corresponding position of the mouse pointer. The \device captures a trace of the mouse pointer position and the click data. Using the mouse trace data, the \device computes a \emph{\pop}. The \pop serves as an indirect measure for the input integrity as the \device confirms the remote server that if the user drags/clicks the mouse in a way that results in an input to the remote server. The \device also overlays a mouse-pointer image on the host's cursor. The overlaid mouse pointer is conspicuous to the user and uses as a safeguard if the host generates multiple pointers. Additionally, the \device employs secure attention sequence (SAS) mechanism that dims all of the display except the overlaid UI and the mouse pointer for user attention.

\myparagraph{\poa} \Poa guarantees that a specific command that is sent to the server is indeed issued legitimately by the user. Any action on the overlaid region of the screen is recorded and signed by the \device.  Direct inputs such as clicking a button or a text data in a text box are signed by the \device and sent to the remote server. These signed input data serves as the second-factor fort the input integrity. The server receives and matches the \emph{applications-level} payload from the browser and the \emph{signed second factor} from the \device. 

\myparagraph{\Poui} All the UI elements that are displayed on the overlaid area is rendered by the \device and signed by the remote server. \Poui ensures that a UI that is seen by the user is legitimately generated by the remote server and reconstructed faithfully by the \device. The JavaScript snippet that is served by the remote server transforms the security-critical UI of the webpage to a QR-code encoded specification. The \device detects the QR code by intercepting the HDMI frame between the host and the display \device. The specification is signed that provides the integrity and the authenticity of both the output data and the UI objects on the webpage. 

\myparagraph{IO integrity and privacy} As the \device also sits on the HDMI channel between the host and display \device, it can overlay objects on the HDMI stream and thus achieves display integrity and privacy. All the objects that are overlaid by the \device can be seen only by the user, and the host is oblivious to the IO.


\fi