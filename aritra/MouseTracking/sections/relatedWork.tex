
\section{Related Work}
\label{sec:relatedWorks}

In Table~\ref{tab:relatedWorks}, we summarize the existing research work based on their trust assumptions, IO security features, and usability. Note that it is desirable to have a lower trust assumption, higher security features, and higher usability. The trust assumption is further refined into hardware trust assumption that includes TEE and external trusted hardware, and software trust assumption, which includes isolated device drivers/APIs and trusted hypervisor/OS. The IO security features involve input that includes keyboard, pointer and touch input, and output that only includes the display. Lastly, the usability aspect is divided into two, the requirement of security indicator (SI), and if the solution supports plug-and-play (PnP). PnP implies that the solution can be integrated into the existing system without introducing any major changes into them and supports different architectures and OS out of the box.

\vspace{-5pt}
\myparagraph{Interpreting the table} The top of the table provides the required security and functional properties that are provided by \name. We list these properties in Section~\ref{sec:problemStatement:goals}. The trust assumption requires as minimum assumptions as possible (property R4). High number of IO security features are more desirable because of properties R1 and R2. The last category that is the usability of a system (in terms of low cognitive load on the users -- R3a and R3b) can be improved if the security is not dependent on a security indicator, and the system provides a plug \& play solution. Hence the systems with more entries in this category have better usability.  


%\myparagraph{Trusted hypervisor/OS-based solutions} Trusted hypervisors and secure micro-kernels are also choices for contrasting Trusted path. Sel4~\cite{klein2009sel4} is a functional hypervisor that is formally verified and has a kernel size of only $8400$ lines of code. In work done by Zhou et al.~\cite{zhou2012building}, the authors proposed a generic trusted path on $x86$ systems in pure hypervisor-based design. Examples of other hypervisor-based works can be found in systems such as Overshadow~\cite{Overshadow}, Virtual ghost~\cite{criswell2014virtual}, Inktag~\cite{hofmann2013inktag}, TrustVisor~\cite{mccune2010trustvisor}, Splitting interfaces~\cite{ta2006splitting}, $SP^3$~\cite{yang2008using}, etc.



%\myparagraph{Trusted Execution Environments} TEEs are other ways to implement a trusted path between the IO devices and the users. Several TEEs such as Intel SGX, ARM TrustZone, TPM, Intel TXT, etc. can be used to achieve such functionality. Previous research works such as Intel SGX and trusted hypervisor-based SGXIO~\cite{weiser2017sgxio}, Intel SGX based ProximiTEE~\cite{dhar2018proximitee}, TPM and TXT based trusted path~\cite{filyanov2011uni}, and ARM TrustZone based trusted path~\cite{filyanov2011uni,sun2015trustotp} are the example of trusted path construction based on TEEs. VButton~\cite{li2018vbutton} uses ARM TrustZone to overlay buttons on the mobile devices that conforms if the user taps on certain buttons.

%\myparagraph{Browser-based solutions} In their paper InContext, author Huang et al.~\cite{huang2012clickjacking} presents different clickjacking attacks variants and their solution by ensuring context (both temporal and visual) and pointer integrity. The pointer integrity is maintained by capturing the screenshot of the UI elements around the pointer and verify with a baseline render of the legitimate UI. The trust model is significantly different from our work as it assumes that the browser
% and the OS are trusted. Such an attacker model makes the continuous tracking of the pointer unnecessary. Moreover, the clickjacking attack focuses on the cases where the JS served from an untrusted web server tricks the user into clicking on a browser rendered UI (such as the microphone/web camera permission widget that is out of control of the JS). In our case, as we assume the OS/browser to be untrusted, the host can execute arbitrary modification on display. This makes the InConext not directly compatible with the attacker model that \name targets. In summary, InContext looks into some of the properties that \name ensures, namely the context of the user and the pointer integrity but in a completely different problem statement (clickjacking vs. trusted path) and trust assumption.

%\myparagraph{Dedicated hardware-based solution} Previous research works such as IntegriKey~\cite{IntegriKey} uses a low-TCB embedded device to introduce a second factor for input integrity. Similar solutions exits such as transaction confirmation devices~\cite{filyanov2011uni} that uses a small display device to show the input parameters to the users.
%Such systems are oblivious to the context of the users and the display device hence attacks where attacker selectively drop characters from the text-field are hard to mitigate.   In their work, Brandon et al. ~\cite{brandon2017trusted} demonstrate screen overlay on Android devices using FPGAs.
