\section{\name: System Design}
\label{sec:systemDesign}


\begin{figure}[t]
\centering
\includegraphics[trim={0 6cm 12cm 0}, clip, width=\linewidth]{systemDesign.pdf}
\caption{High level flow of \name}
\label{fig:systemDesign}
\centering
\end{figure}


% \begin{figure}
% \centering
% \includegraphics[width=\linewidth]{overall.jpg}
% \caption{Overall idea}
% \label{fig:overallIdea}
% \centering
% \end{figure}

Figure~\ref{fig:systemDesign} provides the overall system design of \name. The components of the systems are the following:

\begin{enumerate}
  \item \textbf{Host system.} The host system is completely compromised (hardware, OS and the installed applications) by the attacker.
  \item \textbf{\device.} The \device is connected to the input devices and sits between the host and the display. The \device is connected to the input devices over \usb interface and connected to the host and the display over HDMI.
  \item \textbf{Input device.}
  \item \textbf{Display.}
  
\end{enumerate}

\myparagraph{Initialization} 
There are two steps of initialization process:

\begin{enumerate}
  \item\textbf{IO initialization.} The \device initializes the mouse by instructing the host system to move the mouse pointer to the top right corner (moving to the first right and then up for an arbitrarily large value). As the \device has access to the frames that are displayed on the screen, it can verify if the mouse pointer is at the top-right corner of the screen or not. Then it instructs the host OS to bring it to the center of the screen.
  
  \item\textbf{Network initialization.} The \device connects to the remote server using \webusb or \webbt. effectively using the host as an untrusted transport. The \device and the server establishes a secure channel with the public certificates that are distributed before-hand.
\end{enumerate}

The outline of the system is illustrated in Figure~\ref{fig:systemDesign}. The steps are the following:


\begin{enumerate}
  \item[\one] The user provides input from her input device which is captured by the \device.
  \item[\two] The \device sends the mouse traces to the host over the \bluetooth interface.
  \item[\three] The host system draws the frames.
  \item[\four] The host sends the drawn frames to the \device over HDMI interface.
  \item[\five] The host sends the \http request to the remote server that contains user input. 
  \item[\six] The remote server sends the UI information to the \device over the dedicated \tls channel between the \device and the remote server. The packet includes information such as the type of the UI, text that is expected on the UI etc.
  \item[\seven] The \device analyzes the frames (from step \four) from the host using the UI information (step \six) received from the server. The analysis step is discussed in details in Section~\ref{sec:systemnDesign:analysis}.
  \item[\eight] The \device sends the frames and the overlay derived from the analysis step to the display device.

\end{enumerate}



\begin{figure}[t]
\centering
\includegraphics[trim={0 5.8cm 13cm 0}, clip, width=\linewidth]{flow.pdf}
\caption{Protocol}
\label{fig:protocol}
\centering
\end{figure}


\subsection{Protocol}



\begin{figure}[t]
\centering
\includegraphics[trim={0 5.8cm 8cm 0}, clip, width=\linewidth]{mouseAnalysis.pdf}
\caption{Analysis of the frames in comparison with the mouse trace}
\label{fig:mouseAnalysis}
\centering
\end{figure}

% \begin{figure}
% \centering
% \includegraphics[width=\linewidth]{mouse_track.jpg}
% \caption{Analysis of the frames in comparison with the mouse trace}
% \label{fig:mouseAnalysis}
% \centering
% \end{figure}

\subsection{Analysis of host frames}
\label{sec:systemnDesign:analysis}

Figure~\ref{fig:mouseAnalysis} illustrates the high-level idea of the host system display frame analysis. To match the mouse polling rate with the display frame rate, the \device only queries the input device with the frequency of $60$ Hz. We assume that over the HDMI channel the host system sends frames at the rate of $60$ fps. The analysis works like the following. We define mouse movement as the time series $(x,y)$ co-ordinates $\{(x_1,y_1), (x_2, y_2), \ldots, (x_n,y_n)\}$ from time $\{t_1, t_2, \ldots, t_n\}$. Assume that the frames coming from the host system to the \device are: $\{f_1, f_2, \ldots, f_n\}$. In time $t_i$, the \device looks into the frame $f_i$ and draws a square centered at $(x_i, y_i)$ with sides of length $X$ (enough to cover a mouse cursor). Then the \device checks if there exists a mouse inside this square or not. In case there exists a mouse cursor, the \device allows further user interactions otherwise it stops all the communications and shows an error on the display.

\begin{figure}[t]
\centering
\includegraphics[trim={0 12cm 17cm 0}, clip, width=0.8\linewidth]{uiDetect.pdf}
\caption{Detection of the UI elements upon mouse click event in the incoming frame.}
\label{fig:uiDetect}
\centering
\end{figure}

% \begin{figure}
% \centering
% \includegraphics[width=\linewidth]{ui_detect.jpg}
% \caption{Detection of UI elements}
% \label{fig:uiDetect}
% \centering
% \end{figure}

\subsection{Detecting UI elements}
\label{sec:systemnDesign:uiElements}

Detecting the UI elements triggers when the user clicks. The \device uses a square of $X$ sq. pixels around the mouse pointer and analyze the image. Figure~\ref{fig:uiDetect} illustrates an example of detecting the UI element from the captured frame. For example, if the user clicks on a button, the \device executes the image analysis on the part of the image to try to figure out if there is a button and parse the text. Additionally, the \device also sends the button text to the server. The server checks the data sent by the \device and the data received from the browser and compares them. In case there is a mismatch, the server notifies the \device and the \device overlays an error message on the screen. 


\begin{figure}[h]
\centering
\includegraphics[trim={0 11cm 16.5cm 0}, clip, width=\linewidth]{inputPrivacy.pdf}
\caption{Input privacy}
\label{fig:inputPrivacy}
\centering
\end{figure}

\subsection{Input privacy}
\label{sec:systemnDesign:inputPrivacy}

\name provides input privacy from the malicious host. The input privacy feature keeps the malicious host from knowing the sensitive input from the user to the remote server. The outline of the protocol is illustrated in Figure~\ref{fig:inputPrivacy}. The flow of the protocol is as the following:

\begin{enumerate}
  \item[\one] User input from the keyboard to the \device.
  \item[\two] The \device encrypts the data and sends to the host.
  \item[\three] The host renders the frame and send it to the \device.
  \item[\four] The \device overlays the plain text information on the frame and sends it to the display device.
\end{enumerate}


\begin{figure}[h]
\centering
\includegraphics[trim={0 11cm 19cm 0}, clip, width=\linewidth]{outputPrivacy.pdf}
\caption{Output privacy}
\label{fig:outputPrivacy}
\centering
\end{figure}

\lstset{language=HTML, frame=tb, caption=\textbf{Partially encrypted HTML page.} , label = snippet:encryptedHTML, firstnumber =1}
\begin{figure}[t]
\small
\begin{lstlisting}[mathescape=true]
<!DOCTYPE html>
<html> <body>
<form action="/some_action">
  First name:<br>
  <input type="text" name="First name">
  <br> Last name:<br>
  <input type="text" name="name">
  <encrypted>
  [encrypted data]
  </encrypted>
  <input type="submit" value="Submit">
</form> </body> </html>
\end{lstlisting} 
\end{figure}


\lstset{language=HTML, frame=tb, caption=\textbf{Equivalent decrypted HTML page of Specification~\ref{snippet:encryptedHTML}.} , label = snippet:decryptedHTML, firstnumber =1}
\begin{figure}[t]
\small
\begin{lstlisting}[mathescape=true]
<!DOCTYPE html>
<html> <body>
<form action="/some_action">
  First name:<br>
  <input type="text" name="First name">
  <br> Last name:<br>
  <input type="text" name="name">
  <input type="radio" name="candidate1"> Candidate 1
  <input type="radio" name="candidate2"> Candidate 2
  <input type="submit" value="Submit">
</form> </body> </html>
\end{lstlisting} 
\end{figure}




\begin{figure}[h]
\centering
\includegraphics[trim={0 7cm 20cm 0}, clip, width=0.65\linewidth]{activityPrivacyRender.pdf}
\caption{Activity privacy}
\label{fig:activityPrivacy}
\centering
\end{figure}


\subsection{Activity Privacy}
\label{sec:systemnDesign:mousePrivacy}

The host system can be made fully oblivious of the mouse pointer, user activity and UI for a small portion of the browser that handles sensitive data or operations. We call this part of the display \emph{Oblivious Window} (OW). We opted out from the device rendering the HTML element inside the OW. Figure~\ref{fig:activityPrivacy} shows the overall construct of this idea. The server stores pre-rendered images corresponding to the OW and send the encrypted image along with the HTML page to the host system. The host renders the webpage along with an encrypted OW encoded as a QR code. The content of the QR code is encrypted with the \tls key that is shared between the device and the remote server.

The flow of the system can be divided into three parts: initialization, operation and update.

\myparagraph{Initialization.} The initialization phase establishes a secure channel between the device and the remote server over the HTTP channel between the host and the remote host. The \js snippet that is served by the remote server handles the handshake between the device and remote server that is required to establish the secure channel. The flow of the system is the following: 
\begin{enumerate}
  \item The user initiates a fresh session by pressing a button on the device. This makes the device ready for a initialization phased with a remote server.
  \item When the user loads the web page from the remote server for the first time, the remote server sends its public certificate signed by a CA encoded in a QR code. 
  \item The device reads the QR and sends keyboard events that encode the signed public certificate of the device's public key in base64 encoded format. The \js served by the remote serve gets the key strokes and generates a \texttt{XMLHttpRequest}.
  \item After exchanging the signed public certificates, the device and the remote server generates a shared secret that is used to encrypt and authenticate communications between the device and the remote server.
\end{enumerate}


\subsection{Output Privacy}
\label{sec:systemDesign:outputPrivacy}

\name provides output privacy and integrity protection of the output. One can think of this property as the ability to retrieve information from the remote server and display it to the user where the host system remains oblivious to the sensitive information. The overall flow of the system is illustrated in Figure~\ref{fig:outputPrivacy}. The steps are the following:

\begin{enumerate}
  \item[\one] The server sends the webpage and the encrypted data to the host over the \http connection between the browser and the remote server.
  \item[\two] The host generates the display frames and the encrypted data from the server and send them to the \device over the HDMI.
  \item[\three] The \device decrypts the encrypted data and overlay them on the frames that are received from the host.
  \item[\four] The \device sends the frames and corresponding overlays to the display device where the user sees them.
\end{enumerate}



